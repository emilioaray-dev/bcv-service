# Nombre del workflow que aparecer√° en la pesta√±a "Actions" de GitHub
name: Build, Publish and Deploy

# Define cu√°ndo se debe ejecutar este workflow
on:
  # Se activa en cada "push" a la rama "main"
  push:
    branches:
      - main

# Define los trabajos (jobs) que se van a ejecutar
jobs:
  build-and-push-image:
    # ¬°Importante! Le dice a GitHub que use tu runner autoalojado
    runs-on: self-hosted

    # Los pasos que ejecutar√° el runner
    steps:
      # 1. Clona tu repositorio en el runner para tener acceso al c√≥digo y al Dockerfile
      - name: Check out the repo
        uses: actions/checkout@v4

      # 2. Inicia sesi√≥n en el GitHub Container Registry (ghcr.io)
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          # El usuario es tu nombre de usuario de GitHub
          username: ${{ github.actor }}
          # La contrase√±a es el token que guardamos como secreto
          password: ${{ secrets.GH_PAT }}

      # 3. Extrae metadatos (como las etiquetas) para la imagen de Docker
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          # Define el nombre de la imagen usando tu usuario/organizaci√≥n y nombre de repositorio
          images: ghcr.io/${{ github.repository }}

      # 4. Construye la imagen de Docker y la sube al registro
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          # Usa las etiquetas generadas en el paso anterior (ej: latest, y una por commit)
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # Job de deployment autom√°tico a Proxmox VM
  deploy-to-proxmox:
    name: Deploy to Proxmox VM
    runs-on: self-hosted
    needs: build-and-push-image
    # Solo ejecutar si el build fue exitoso
    if: success()

    steps:
      - name: Deploy to Proxmox via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROXMOX_HOST }}
          username: ${{ secrets.PROXMOX_USER }}
          key: ${{ secrets.PROXMOX_SSH_KEY }}
          port: ${{ secrets.PROXMOX_PORT || 22 }}
          script: |
            set -e  # Salir inmediatamente si un comando falla

            echo "üöÄ Iniciando deployment en Proxmox VM"
            echo "üì¶ Imagen: ghcr.io/${{ github.repository }}:main"

            # Navegar al directorio del proyecto
            PROJECT_PATH="${{ secrets.PROXMOX_PROJECT_PATH || '/opt/bcv-service' }}"
            if [ ! -d "$PROJECT_PATH" ]; then
              echo "‚ùå Error: Directorio $PROJECT_PATH no existe"
              exit 1
            fi
            cd "$PROJECT_PATH"
            echo "üìÅ Directorio: $PROJECT_PATH"

            # Detectar comando docker-compose disponible
            if command -v docker compose &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            elif command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE="docker-compose"
            else
              echo "‚ùå Error: docker-compose no est√° instalado"
              exit 1
            fi
            echo "üîß Usando comando: $DOCKER_COMPOSE"

            # Determinar qu√© archivo docker-compose usar
            if [ -f "docker-compose.production.yml" ]; then
              COMPOSE_FILE="docker-compose.production.yml"
            elif [ -f "docker-compose.yml" ]; then
              COMPOSE_FILE="docker-compose.yml"
            else
              echo "‚ùå Error: No se encontr√≥ archivo docker-compose"
              exit 1
            fi
            echo "üìÑ Usando archivo: $COMPOSE_FILE"

            # Mostrar estado actual
            echo "üìä Estado actual de contenedores:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE ps || true

            # Hacer login en GitHub Container Registry
            echo "üîê Autenticando en GHCR..."
            echo ${{ secrets.GH_PAT }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Descargar la nueva imagen
            echo "‚¨áÔ∏è Descargando nueva imagen..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE pull bcv-service

            # Detener y eliminar contenedores antiguos
            echo "üõë Deteniendo contenedores..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE down

            # Iniciar con la nueva imagen
            echo "‚ñ∂Ô∏è Iniciando contenedores actualizados..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE up -d

            # Esperar a que los servicios est√©n saludables
            echo "‚è≥ Esperando a que los servicios est√©n listos..."
            sleep 15

            # Verificar que los contenedores est√©n corriendo
            echo "üîç Verificando contenedores..."
            RUNNING_CONTAINERS=$($DOCKER_COMPOSE -f $COMPOSE_FILE ps --services --filter "status=running" | wc -l)
            TOTAL_SERVICES=$($DOCKER_COMPOSE -f $COMPOSE_FILE config --services | wc -l)

            if [ "$RUNNING_CONTAINERS" -eq "$TOTAL_SERVICES" ]; then
              echo "‚úÖ Todos los contenedores est√°n corriendo ($RUNNING_CONTAINERS/$TOTAL_SERVICES)"
            else
              echo "‚ùå Error: Solo $RUNNING_CONTAINERS de $TOTAL_SERVICES contenedores est√°n corriendo"
              echo "üìä Estado de contenedores:"
              $DOCKER_COMPOSE -f $COMPOSE_FILE ps
              echo "üìù Logs de error:"
              $DOCKER_COMPOSE -f $COMPOSE_FILE logs --tail=50
              exit 1
            fi

            # Verificar estado final
            echo "‚úÖ Estado final de contenedores:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE ps

            # Verificar logs recientes
            echo "üìù Logs recientes del servicio:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE logs --tail=20 bcv-service

            # Limpiar im√°genes antiguas
            echo "üßπ Limpiando im√°genes antiguas..."
            docker image prune -f

            echo "‚úÖ Deployment completado exitosamente!"
