# Nombre del workflow que aparecerÃ¡ en la pestaÃ±a "Actions" de GitHub
name: CI/CD Pipeline with Semantic Release

# Define cuÃ¡ndo se debe ejecutar este workflow
on:
  # Se activa en cada "push" a la rama "main"
  push:
    branches:
      - main

# Define los trabajos (jobs) que se van a ejecutar
jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 1: VALIDATE & TEST
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  validate-and-test:
    name: ğŸ§ª Validate & Test
    runs-on: self-hosted

    steps:
      # 1. Clona el repositorio
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para semantic-release

      # 2. Setup Node.js
      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      # 3. Instalar dependencias
      - name: ğŸ“¦ Install dependencies
        run: pnpm install --frozen-lockfile

      # 4. Linting con Biome
      - name: ğŸ” Run Biome linter
        run: pnpm lint

      # 5. Type checking
      - name: ğŸ” TypeScript type checking
        run: pnpm tsc --noEmit

      # 6. Run tests
      - name: ğŸ§ª Run tests
        run: pnpm test

      # 7. Build project
      - name: ğŸ—ï¸ Build project
        run: pnpm build

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 2: SEMANTIC RELEASE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  semantic-release:
    name: ğŸš€ Semantic Release
    runs-on: self-hosted
    needs: validate-and-test  # Solo ejecutar si los tests pasaron
    outputs:
      # Determinar si se publicÃ³ una nueva versiÃ³n comparando la versiÃ³n antes y despuÃ©s
      new-release-published: ${{ steps.version_check.outputs.new-release-published }}

    steps:
      # 1. Obtener la versiÃ³n actual antes de semantic-release
      - name: ğŸ“‹ Get current version before semantic-release
        id: get_version_before
        run: |
          if [ -f package.json ]; then
            VERSION=$(node -p "require('./package.json').version")
            echo "version_before=$VERSION" >> $GITHUB_OUTPUT
            echo "Current version before: $VERSION"
          else
            echo "version_before=0.0.0" >> $GITHUB_OUTPUT
            echo "package.json not found, setting default version"
          fi

      # 2. Checkout con historial completo para semantic-release
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Historial completo necesario
          token: ${{ secrets.GH_PAT }}  # Token con permisos para hacer push

      # 3. Setup Node.js
      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      # 4. Instalar dependencias
      - name: ğŸ“¦ Install dependencies
        run: pnpm install --frozen-lockfile

      # 5. Configurar Git
      - name: ğŸ”§ Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # 6. Run Semantic Release
      - name: ğŸš€ Run Semantic Release
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          branch: main
          extra_plugins: |
            @semantic-release/changelog
            @semantic-release/git

      # 7. Obtener la versiÃ³n despuÃ©s de semantic-release y comparar
      - name: ğŸ“‹ Check if release was published by comparing versions
        id: version_check
        run: |
          VERSION_AFTER=$(node -p "require('./package.json').version")
          VERSION_BEFORE="${{ steps.get_version_before.outputs.version_before }}"

          echo "Version before: $VERSION_BEFORE"
          echo "Version after: $VERSION_AFTER"

          if [ "$VERSION_AFTER" != "$VERSION_BEFORE" ]; then
            echo "new-release-published=true" >> $GITHUB_OUTPUT
            echo "Version changed, new release published"
            echo "ğŸ‰ New release published: $VERSION_BEFORE -> $VERSION_AFTER"
          else
            echo "new-release-published=false" >> $GITHUB_OUTPUT
            echo "No version change, no new release published"
          fi

      # 8. Log release information
      - name: ğŸ“Š Log release information
        if: steps.version_check.outputs.new-release-published == 'true'
        run: |
          VERSION_AFTER=$(node -p "require('./package.json').version")
          echo "ğŸ‰ New release published!"
          echo "ğŸ“¦ Version: $VERSION_AFTER"
          echo "ğŸ·ï¸ Tag: v$VERSION_AFTER"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 3: BUILD & PUBLISH DOCKER IMAGE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-and-push-image:
    name: ğŸ³ Build & Publish Docker Image
    runs-on: self-hosted
    needs: semantic-release
    # Solo ejecutar si se publicÃ³ una nueva versiÃ³n
    if: needs.semantic-release.outputs.new-release-published == 'true'

    steps:
      # 1. Checkout del cÃ³digo
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Asegurar que usamos main con la versiÃ³n actualizada
          fetch-depth: 0

      # 2. Pull latest changes (incluye el commit de semantic-release)
      - name: ğŸ”„ Pull latest changes
        run: git pull origin main

      # 3. Extraer versiÃ³n desde package.json
      - name: ğŸ“¦ Extract version from package.json
        id: package_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Version: $VERSION"

          # Extraer versiÃ³n mayor.menor (ej: 1.0 de 1.0.2)
          MAJOR_MINOR=$(echo $VERSION | cut -d. -f1-2)
          echo "major_minor=$MAJOR_MINOR" >> $GITHUB_OUTPUT
          echo "ğŸ“Š Major.Minor: $MAJOR_MINOR"

          # Extraer solo versiÃ³n mayor (ej: 1 de 1.0.2)
          MAJOR=$(echo $VERSION | cut -d. -f1)
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "ğŸ”¢ Major: $MAJOR"

      # 4. Login a GitHub Container Registry
      - name: ğŸ” Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      # 5. Generar metadata para Docker
      - name: ğŸ·ï¸ Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=${{ steps.package_version.outputs.version }}
            type=raw,value=${{ steps.package_version.outputs.major_minor }}
            type=raw,value=${{ steps.package_version.outputs.major }}
            type=raw,value=latest
            type=raw,value=main

      # 6. Build y Push Docker image
      - name: ğŸ”¨ Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # 7. Log de imÃ¡genes creadas
      - name: ğŸ“ Log created images
        run: |
          echo "âœ… Docker images published:"
          echo "  - ghcr.io/${{ github.repository }}:${{ steps.package_version.outputs.version }}"
          echo "  - ghcr.io/${{ github.repository }}:${{ steps.package_version.outputs.major_minor }}"
          echo "  - ghcr.io/${{ github.repository }}:${{ steps.package_version.outputs.major }}"
          echo "  - ghcr.io/${{ github.repository }}:latest"
          echo "  - ghcr.io/${{ github.repository }}:main"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 4: DEPLOY TO PROXMOX
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-to-proxmox:
    name: ğŸš€ Deploy to Proxmox VM
    runs-on: self-hosted
    needs: [semantic-release, build-and-push-image]
    # Solo ejecutar si el build fue exitoso
    if: success() && needs.semantic-release.outputs.new-release-published == 'true'

    steps:
      # 1. Checkout para acceder a package.json
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      # 2. Pull latest changes
      - name: ğŸ”„ Pull latest changes
        run: git pull origin main

      # 3. Extraer versiÃ³n para deployment
      - name: ğŸ“¦ Get version for deployment
        id: deploy_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Deploying version: $VERSION"

      # 4. Deploy via SSH
      - name: ğŸš€ Deploy to Proxmox via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROXMOX_HOST }}
          username: ${{ secrets.PROXMOX_USER }}
          key: ${{ secrets.PROXMOX_SSH_KEY }}
          port: ${{ secrets.PROXMOX_PORT || 22 }}
          script: |
            set -e  # Salir inmediatamente si un comando falla

            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸš€ INICIANDO DEPLOYMENT EN PROXMOX VM"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ VersiÃ³n: ${{ steps.deploy_version.outputs.version }}"
            echo "ğŸ³ Imagen: ghcr.io/${{ github.repository }}:latest"
            echo "ğŸ• Fecha: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            # Navegar al directorio del proyecto
            PROJECT_PATH="${{ secrets.PROXMOX_PROJECT_PATH || '/opt/bcv-service' }}"
            if [ ! -d "$PROJECT_PATH" ]; then
              echo "âŒ Error: Directorio $PROJECT_PATH no existe"
              exit 1
            fi
            cd "$PROJECT_PATH"
            echo "ğŸ“ Directorio: $PROJECT_PATH"

            # Detectar comando docker-compose disponible
            if command -v docker compose &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            elif command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE="docker-compose"
            else
              echo "âŒ Error: docker-compose no estÃ¡ instalado"
              exit 1
            fi
            echo "ğŸ”§ Usando comando: $DOCKER_COMPOSE"

            # Determinar quÃ© archivo docker-compose usar
            if [ -f "docker-compose.production.yml" ]; then
              COMPOSE_FILE="docker-compose.production.yml"
            elif [ -f "docker-compose.yml" ]; then
              COMPOSE_FILE="docker-compose.yml"
            else
              echo "âŒ Error: No se encontrÃ³ archivo docker-compose"
              exit 1
            fi
            echo "ğŸ“„ Usando archivo: $COMPOSE_FILE"

            # Mostrar estado actual
            echo ""
            echo "ğŸ“Š Estado actual de contenedores:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE ps || true

            # Hacer login en GitHub Container Registry
            echo ""
            echo "ğŸ” Autenticando en GHCR..."
            echo ${{ secrets.GH_PAT }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Descargar la nueva imagen
            echo ""
            echo "â¬‡ï¸  Descargando nueva imagen (versiÃ³n ${{ steps.deploy_version.outputs.version }})..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE pull bcv-service

            # Detener y eliminar contenedores antiguos
            echo ""
            echo "ğŸ›‘ Deteniendo contenedores..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE down

            # Iniciar con la nueva imagen
            echo ""
            echo "â–¶ï¸  Iniciando contenedores actualizados..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE up -d

            # Esperar a que los servicios estÃ©n saludables
            echo ""
            echo "â³ Esperando a que los servicios estÃ©n listos..."
            sleep 15

            # Verificar que los contenedores estÃ©n corriendo
            echo ""
            echo "ğŸ” Verificando contenedores..."
            RUNNING_CONTAINERS=$($DOCKER_COMPOSE -f $COMPOSE_FILE ps --services --filter "status=running" | wc -l)
            TOTAL_SERVICES=$($DOCKER_COMPOSE -f $COMPOSE_FILE config --services | wc -l)

            if [ "$RUNNING_CONTAINERS" -eq "$TOTAL_SERVICES" ]; then
              echo "âœ… Todos los contenedores estÃ¡n corriendo ($RUNNING_CONTAINERS/$TOTAL_SERVICES)"
            else
              echo "âŒ Error: Solo $RUNNING_CONTAINERS de $TOTAL_SERVICES contenedores estÃ¡n corriendo"
              echo ""
              echo "ğŸ“Š Estado de contenedores:"
              $DOCKER_COMPOSE -f $COMPOSE_FILE ps
              echo ""
              echo "ğŸ“ Logs de error:"
              $DOCKER_COMPOSE -f $COMPOSE_FILE logs --tail=50
              exit 1
            fi

            # Verificar estado final
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âœ… DEPLOYMENT COMPLETADO EXITOSAMENTE"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ VersiÃ³n desplegada: ${{ steps.deploy_version.outputs.version }}"
            echo "ğŸ• Completado: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""
            echo "ğŸ“Š Estado final de contenedores:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE ps
            echo ""
            echo "ğŸ“ Logs recientes del servicio:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE logs --tail=20 bcv-service

            # Limpiar imÃ¡genes antiguas
            echo ""
            echo "ğŸ§¹ Limpiando imÃ¡genes antiguas..."
            docker image prune -f

            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
