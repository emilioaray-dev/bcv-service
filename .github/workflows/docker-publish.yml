# Nombre del workflow que aparecerรก en la pestaรฑa "Actions" de GitHub
name: CI/CD Pipeline with Semantic Release

# Define cuรกndo se debe ejecutar este workflow
on:
  # Se activa en cada "push" a la rama "main"
  push:
    branches:
      - main

# Define los trabajos (jobs) que se van a ejecutar
jobs:
  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  # STAGE 1: VALIDATE & TEST
  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  validate-and-test:
    name: ๐งช Validate & Test
    runs-on: self-hosted

    steps:
      # 1. Clona el repositorio
      - name: ๐ฅ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para semantic-release

      # 2. Setup Node.js
      - name: ๐ง Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      # 3. Instalar dependencias
      - name: ๐ฆ Install dependencies
        run: pnpm install --frozen-lockfile

      # 4. Linting con Biome
      - name: ๐ Run Biome linter
        run: pnpm lint

      # 5. Type checking
      - name: ๐ TypeScript type checking
        run: pnpm tsc --noEmit

      # 6. Run tests
      - name: ๐งช Run tests
        run: pnpm test

      # 7. Build project
      - name: ๐๏ธ Build project
        run: pnpm build

  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  # STAGE 2: SEMANTIC RELEASE
  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  semantic-release:
    name: ๐ Semantic Release
    runs-on: self-hosted
    needs: validate-and-test  # Solo ejecutar si los tests pasaron
    outputs:
      # Determinar si se publicรณ una nueva versiรณn comparando la versiรณn antes y despuรฉs
      new-release-published: ${{ steps.version_check.outputs.new-release-published }}
    steps:
      # 1. Obtener la versiรณn actual antes de semantic-release
      - name: ๐ Get current version before semantic-release
        id: get_version_before
        run: |
          if [ -f package.json ]; then
            VERSION=$(node -p "require('./package.json').version")
            echo "version_before=$VERSION" >> $GITHUB_OUTPUT
            echo "Current version before: $VERSION"
          else
            echo "version_before=0.0.0" >> $GITHUB_OUTPUT
            echo "package.json not found, setting default version"
          fi
      # 2. Checkout con historial completo para semantic-release
      - name: ๐ฅ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Historial completo necesario
          token: ${{ secrets.GH_PAT }}  # Token con permisos para hacer push
      # 3. Setup Node.js
      - name: ๐ง Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
      # 4. Instalar dependencias
      - name: ๐ฆ Install dependencies
        run: pnpm install --frozen-lockfile
      # 5. Configurar Git
      - name: ๐ง Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      # 6. Run Semantic Release
      - name: ๐ Run Semantic Release
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          branch: main
          extra_plugins: |
            @semantic-release/changelog
            @semantic-release/git
      # 7. Obtener la versiรณn despuรฉs de semantic-release y comparar
      - name: ๐ Check if release was published by comparing versions
        id: version_check
        run: |
          VERSION_AFTER=$(node -p "require('./package.json').version")
          VERSION_BEFORE="${{ steps.get_version_before.outputs.version_before }}"
          echo "Version before: $VERSION_BEFORE"
          echo "Version after: $VERSION_AFTER"
          if [ "$VERSION_AFTER" != "$VERSION_BEFORE" ]; then
            echo "new-release-published=true" >> $GITHUB_OUTPUT
            echo "Version changed, new release published"
            echo "๐ New release published: $VERSION_BEFORE -> $VERSION_AFTER"
          else
            echo "new-release-published=false" >> $GITHUB_OUTPUT
            echo "No version change, no new release published"
          fi
      # 8. Log release information
      - name: ๐ Log release information
        if: steps.version_check.outputs.new-release-published == 'true'
        run: |
          VERSION_AFTER=$(node -p "require('./package.json').version")
          echo "๐ New release published!"
          echo "๐ฆ Version: $VERSION_AFTER"
          echo "๐ท๏ธ Tag: v$VERSION_AFTER"

  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  # STAGE 3: BUILD & PUBLISH DOCKER IMAGE
  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  build-and-push-image:
    name: ๐ณ Build & Publish Docker Image
    runs-on: self-hosted
    needs: semantic-release
    # Solo ejecutar si se publicรณ una nueva versiรณn
    if: needs.semantic-release.outputs.new-release-published == 'true'

    steps:
      # 1. Checkout del cรณdigo
      - name: ๐ฅ Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Asegurar que usamos main con la versiรณn actualizada
          fetch-depth: 0

      # 2. Pull latest changes (incluye el commit de semantic-release)
      - name: ๐ Pull latest changes
        run: git pull origin main

      # 3. Extraer versiรณn desde package.json
      - name: ๐ฆ Extract version from package.json
        id: package_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "๐ฆ Version: $VERSION"

          # Extraer versiรณn mayor.menor (ej: 1.0 de 1.0.2)
          MAJOR_MINOR=$(echo $VERSION | cut -d. -f1-2)
          echo "major_minor=$MAJOR_MINOR" >> $GITHUB_OUTPUT
          echo "๐ Major.Minor: $MAJOR_MINOR"

          # Extraer solo versiรณn mayor (ej: 1 de 1.0.2)
          MAJOR=$(echo $VERSION | cut -d. -f1)
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "๐ข Major: $MAJOR"

      # 4. Login a GitHub Container Registry
      - name: ๐ Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      # 5. Generar metadata para Docker
      - name: ๐ท๏ธ Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=${{ steps.package_version.outputs.version }}
            type=raw,value=${{ steps.package_version.outputs.major_minor }}
            type=raw,value=${{ steps.package_version.outputs.major }}
            type=raw,value=latest
            type=raw,value=main

      # 6. Clean up disk space before Docker build
      - name: ๐งน Clean up disk space
        run: |
          # Clean up pnpm cache
          pnpm store prune
          # Clean up Docker cache
          docker system prune -f
          # Clean up npm cache as well
          npm cache clean --force
          # Clean up any temporary files
          rm -rf /tmp/*

      # 7. Build y Push Docker image
      - name: ๐จ Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # 7. Log de imรกgenes creadas
      - name: ๐ Log created images
        run: |
          echo "โ Docker images published:"
          echo "  - ghcr.io/${{ github.repository }}:${{ steps.package_version.outputs.version }}"
          echo "  - ghcr.io/${{ github.repository }}:${{ steps.package_version.outputs.major_minor }}"
          echo "  - ghcr.io/${{ github.repository }}:${{ steps.package_version.outputs.major }}"
          echo "  - ghcr.io/${{ github.repository }}:latest"
          echo "  - ghcr.io/${{ github.repository }}:main"

  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  # STAGE 4: DEPLOY TO PROXMOX
  # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
  deploy-to-proxmox:
    name: ๐ Deploy to Proxmox VM
    runs-on: self-hosted
    needs: [semantic-release, build-and-push-image]
    # Solo ejecutar si se publicรณ una nueva versiรณn
    if: success() && needs.semantic-release.outputs.new-release-published == 'true'

    steps:
      # 1. Checkout para acceder a package.json (silencioso)
      - name: ๐ฅ Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          show-progress: false  # Deshabilita el progreso de git

      # 2. Pull latest changes (silencioso)
      - name: ๐ Pull latest changes
        run: git pull origin main --quiet

      # 3. Extraer versiรณn para deployment
      - name: ๐ฆ Get version for deployment
        id: deploy_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "๐ฆ Deploying version: $VERSION"

      # 4. Deploy via SSH
      - name: ๐ Deploy to Proxmox via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROXMOX_HOST }}
          username: ${{ secrets.PROXMOX_USER }}
          key: ${{ secrets.PROXMOX_SSH_KEY }}
          port: ${{ secrets.PROXMOX_PORT || 22 }}
          timeout: 60m  # Timeout de 60 minutos para descarga de imรกgenes grandes
          command_timeout: 60m  # Timeout para comandos individuales (docker pull)
          script: |
            set -e  # Salir inmediatamente si un comando falla

            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "๐ INICIANDO DEPLOYMENT EN PROXMOX VM"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "๐ฆ Versiรณn: ${{ steps.deploy_version.outputs.version }}"
            echo "๐ณ Imagen: ghcr.io/${{ github.repository }}:latest"
            echo "๐ Fecha: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"

            # Navegar al directorio del proyecto
            PROJECT_PATH="${{ secrets.PROXMOX_PROJECT_PATH || '/opt/bcv-service' }}"
            if [ ! -d "$PROJECT_PATH" ]; then
              echo "โ Error: Directorio $PROJECT_PATH no existe"
              exit 1
            fi
            cd "$PROJECT_PATH"
            echo "๐ Directorio: $PROJECT_PATH"

            # Detectar comando docker-compose disponible
            if command -v docker compose &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            elif command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE="docker-compose"
            else
              echo "โ Error: docker-compose no estรก instalado"
              exit 1
            fi
            echo "๐ง Usando comando: $DOCKER_COMPOSE"

            # Determinar quรฉ archivo docker-compose usar
            if [ -f "docker-compose.production.yml" ]; then
              COMPOSE_FILE="docker-compose.production.yml"
            elif [ -f "docker-compose.yml" ]; then
              COMPOSE_FILE="docker-compose.yml"
            else
              echo "โ Error: No se encontrรณ archivo docker-compose"
              exit 1
            fi
            echo "๐ Usando archivo: $COMPOSE_FILE"

            # Mostrar estado actual
            echo ""
            echo "๐ Estado actual de contenedores:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE ps 2>&1 | grep -v "version.*obsolete" || true

            # Hacer login en GitHub Container Registry (silenciar warnings)
            echo ""
            echo "๐ Autenticando en GHCR..."
            echo ${{ secrets.GH_PAT }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin 2>&1 | grep -v "WARNING" || true

            # Exportar secretos como variables de entorno para docker-compose
            echo ""
            echo "๐ Configurando secretos desde GitHub..."
            export MONGODB_URI="${{ secrets.MONGODB_URI }}"
            export API_KEYS="${{ secrets.API_KEYS }}"
            export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
            export WEBHOOK_URL="${{ secrets.WEBHOOK_URL }}"
            export DISCORD_WEBHOOK_URL="${{ secrets.DISCORD_WEBHOOK_URL }}"
            export SERVICE_STATUS_WEBHOOK_URL="${{ secrets.SERVICE_STATUS_WEBHOOK_URL }}"
            export DEPLOYMENT_WEBHOOK_URL="${{ secrets.DEPLOYMENT_WEBHOOK_URL }}"
            export SWAGGER_PROD_URL="${{ secrets.SWAGGER_PROD_URL }}"
            echo "โ Secretos configurados correctamente"

            # Descargar la nueva imagen (mostrar progreso, filtrar solo warnings)
            echo ""
            echo "โฌ๏ธ  Descargando nueva imagen (versiรณn ${{ steps.deploy_version.outputs.version }})..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE pull bcv-service 2>&1 | grep -v "version.*obsolete" || true

            # Detener y eliminar contenedores antiguos (silenciar warnings)
            echo ""
            echo "๐ Deteniendo contenedores..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE down 2>&1 | grep -v "version.*obsolete" || true

            # Iniciar con la nueva imagen (silenciar warnings)
            echo ""
            echo "โถ๏ธ  Iniciando contenedores actualizados..."
            $DOCKER_COMPOSE -f $COMPOSE_FILE up -d 2>&1 | grep -v "version.*obsolete" || true

            # Esperar a que los servicios estรฉn saludables
            echo ""
            echo "โณ Esperando a que los servicios estรฉn listos..."
            sleep 15

            # Verificar que los contenedores estรฉn corriendo
            echo ""
            echo "๐ Verificando contenedores..."
            RUNNING_CONTAINERS=$($DOCKER_COMPOSE -f $COMPOSE_FILE ps --services --filter "status=running" 2>/dev/null | wc -l)
            TOTAL_SERVICES=$($DOCKER_COMPOSE -f $COMPOSE_FILE config --services 2>/dev/null | wc -l)

            if [ "$RUNNING_CONTAINERS" -eq "$TOTAL_SERVICES" ]; then
              echo "โ Todos los contenedores estรกn corriendo ($RUNNING_CONTAINERS/$TOTAL_SERVICES)"
            else
              echo "โ Error: Solo $RUNNING_CONTAINERS de $TOTAL_SERVICES contenedores estรกn corriendo"
              echo ""
              echo "๐ Estado de contenedores:"
              $DOCKER_COMPOSE -f $COMPOSE_FILE ps
              echo ""
              echo "๐ Logs de error:"
              $DOCKER_COMPOSE -f $COMPOSE_FILE logs --tail=50
              exit 1
            fi

            # Verificar estado final
            echo ""
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "โ DEPLOYMENT COMPLETADO EXITOSAMENTE"
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
            echo "๐ฆ Versiรณn desplegada: ${{ steps.deploy_version.outputs.version }}"
            echo "๐ Completado: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""
            echo "๐ Estado final de contenedores:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE ps
            echo ""
            echo "๐ Logs recientes del servicio:"
            $DOCKER_COMPOSE -f $COMPOSE_FILE logs --tail=20 bcv-service

            # Limpiar imรกgenes antiguas
            echo ""
            echo "๐งน Limpiando imรกgenes antiguas..."
            docker image prune -f

            echo ""
            echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
